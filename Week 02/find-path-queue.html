<!DOCTYPE html>
<html>
  <head>
    <title>editor-map</title>
    <style>
      #container {
        width: 701px;
        margin-bottom: 20px;
        font-size: 0px;
      }
      .cell {
        width: 6px;
        height: 6px;
        display: inline-block;
        background-color: gray;
        border-right: 1px solid white;
        border-bottom: 1px solid white;
        vertical-align: middle;
      }
      .black {
        background-color: black;
      }
      .green {
        background-color: lightgreen;
      }
      .purple {
        background-color: purple;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <button onclick="save()">save</button>
    <script>
      class ArrayQueue {
        constructor(capacity) {
          this.head = 0
          this.tail = 0
          this.item = new Array(capacity)
          this.n = capacity
        }
        dequeue() {
          const { head, tail, item } = this
          if (head === tail) return null
          const ret = item[head]
          this.head++
          return ret
        }
        enqueue(str) {
          const { head, tail, item, n } = this

          // 队列末尾没有空间了
          if (tail === n) {
            if (head === 0) return false
            for (let i = head; i < tail; i++) {
              item[i - head] = item[i]
            }
            this.tail -= head
            this.head = 0
          }
          item[this.tail] = str
          this.tail++
          return true
        }
        get length() {
          return this.item.length
        }
      }
      const SIZE = 100
      const utils = {
        sleep(time) {
          return new Promise((resolve, reject) => {
            setTimeout(resolve, time)
          })
        },
        createMap() {
          return sessionStorage.map
            ? JSON.parse(sessionStorage.map)
            : Array(SIZE * SIZE).fill(0)
        },
        query(name) {
          return document.querySelector(name)
        },
        createEle(tag, className) {
          const { append, query, addClass } = utils
          const container = query('#container')
          const el = document.createElement(tag)
          addClass(el, className)
          append(container, el)
          return el
        },
        addClass(el, className) {
          el.className = className || ''
        },
        addEvent(el, name, fn) {
          el.addEventListener(name, fn)
        },
        initEvent() {
          const { addEvent } = utils
          addEvent(document, 'mousedown', (e) => {
            state.mousedown = true
            state.clear = !state.clear
          })
          addEvent(document, 'mouseup', (e) => {
            state.mousedown = false
          })
          document.addEventListener('contextmenu', (e) => {
            e.preventDefault()
          })
        },
        cellListener(cell, index) {
          return () => {
            const { clear, mousedown, map } = state
            const { addClass } = utils
            if (mousedown) {
              if (clear) {
                addClass(cell, 'cell')
                map[index] = 0
              } else {
                addClass(cell, 'cell black')
                map[index] = 1
              }
            }
          }
        },
        append(p, c) {
          p.appendChild(c)
        },
        async insertAround(x, y, queue) {
          const { map, preMap } = state
          const { sleep, addClass, computeIndex } = utils
          const pre = [x, y]
          async function insert(x, y) {
            const index = computeIndex(x, y)
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return
            if (map[index]) return
            const cell = container.children[index]
            addClass(cell, 'cell green')
            map[index] = 2
            preMap[index] = pre
            queue.enqueue([x, y])
          }
          await insert(x, y - 1)
          await insert(x + 1, y - 1)
          await insert(x + 1, y)
          await insert(x + 1, y + 1)
          await insert(x, y + 1)
          await insert(x - 1, y + 1)
          await insert(x - 1, y)
          await insert(x - 1, y - 1)
        },
        computeIndex(x, y) {
          return y * SIZE + x
        },
        async setPath(x, y) {
          const { sleep, addClass, computeIndex, query } = utils
          const container = query('#container')
          const index = computeIndex(x, y)
          let cell = container.children[index]
          await sleep(30)
          addClass(cell, 'cell purple')
        },
        addBar(cell) {
          const { addClass } = utils
          addClass(cell, 'cell black')
        },
      }
      const state = {
        map: utils.createMap(),
        mousedown: false,
        clear: false,
        preMap: {},
      }
      function initMap() {
        const {
          createEle,
          addEvent,
          initEvent,
          cellListener,
          computeIndex,
          addBar,
        } = utils
        const { map } = state
        for (let x = 0; x < SIZE; x++) {
          for (let y = 0; y < SIZE; y++) {
            const cell = createEle('span', 'cell')
            const index = computeIndex(x, y)
            if (map[index]) {
              addBar(cell)
            }
            addEvent(cell, 'mousemove', cellListener(cell, index))
          }
        }
        initEvent()
      }
      function save() {
        const { map } = state
        sessionStorage.map = JSON.stringify(map)
      }
      initMap()

      async function findPath(start, end) {
        const queue = new ArrayQueue(10000)
        queue.enqueue(start)
        const [endX, endY] = end
        const { preMap } = state
        const { insertAround, computeIndex, setPath } = utils
        while (queue.length) {
          let [x, y] = queue.dequeue()
          if (x === endX && y === endY) {
            const [startX, startY] = start
            while (x !== startX || y !== startX) {
              await setPath(x, y)
              const index = computeIndex(x, y)
              ;[x, y] = preMap[index]
            }
            await setPath(x, y)
            return true
          }
          await insertAround(x, y, queue)
        }
        return false
      }
    </script>
  </body>
</html>
